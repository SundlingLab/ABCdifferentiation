---
title: "BD Rhapsody - targeted scRNA & Ab-Seq on Malaria Travellers"
subtitle: "B cell focus"
author: "Alan Dine Courey-Ghaouzi"
date: '`r format(Sys.Date(), "%Y-%m-%d")`'
output:
  html_document:
    toc: true
    toc_float: true
    theme: united
    highlight: pygments
    code_download: yes
abstract: Targeted single cell RNA-Seq was used to assess the transcriptional profiles of FACS sorted CD45+ mononuclear cells from 4 donors at three time-points after infection, focusing on 374 immune response related genes and 29 surface proteins simultaneously.
knit: (function(inputFile, encoding) {
          rmarkdown::render(inputFile,
                            encoding = encoding, 
                            output_file = paste0(
                              xfun::sans_ext(inputFile), '_', Sys.Date(), '.html'),
                                output_dir = "../results/lab_book/")})
---

```{r setup, include=FALSE}
knitr::opts_knit$set(echo = TRUE, root.dir = getwd(),fig.asp=0.3,# fig.width = 6, fig.height = 5,
                     warning = FALSE, message = FALSE)

result.dir <- paste0("results/",Sys.Date(),"/")

## creates result.dir with date in if not existent
ifelse(isFALSE(dir.exists(paste0("../",result.dir))), dir.create(paste0("../",result.dir),recursive = TRUE),"Result directory for today exists already!")
options(stringsAsFactors = FALSE) 
```

```{r eval=FALSE, include=FALSE}
## only needed when renv is not working and everything needs to get re-installed
#renv::hydrate()
#renv::install(c("R.utils","satijalab/seurat-wrappers")) 

## needed packages for monocle
#if (!requireNamespace("BiocManager", quietly = TRUE))
#install.packages("BiocManager")

#BiocManager::install(c('BiocGenerics', 'DelayedArray', 'DelayedMatrixStats',
                       #'limma', 'S4Vectors', 'SingleCellExperiment',
                       #'SummarizedExperiment', 'batchelor', 'Matrix.utils'))

#install.packages("devtools")
#devtools::install_github('cole-trapnell-lab/leidenbase')
#devtools::install_github('cole-trapnell-lab/monocle3')

## complexheatmap
#BiocManager::install("ComplexHeatmap")

## sankey plots
#install.packages("devtools")
#devtools::install_github("davidsjoberg/ggsankey")

## Nebulosa
#BiocManager::install("Nebulosa", force = TRUE)
```

## Needed libraries
```{r message=FALSE, warning=FALSE}
library(rmarkdown)
library(tidyverse)
library(readxl)
library(Seurat)
library(clustree)
library(devtools)
library(enrichR)
library(R.utils)
library(SeuratWrappers)
#library(monocle3)
library(data.table)
library(RColorBrewer)
library(patchwork)
library(ComplexHeatmap)
library(ggsankey) #https://github.com/davidsjoberg/ggsankey
library(ggalluvial)
library(Nebulosa)
library(EnhancedVolcano)
library(ggplot2)
library(ReactomeGSA)
library(venn)
library(harmony)
library(slingshot)
library(tradeSeq)
library(enrichR)
#library(org.Hs.eg.db)
library(ReactomePA)
```

## Load data
```{r message=F}
pbmc <- readRDS("../RhapsodyPub/data/2021-12-17AbSeq_Cell_Calling_qc_cca_wnn_clustering_annotated.rds")
pbmc$Group_rev <- factor(as.factor(pbmc$Group), levels = c("primary", "previously"))

##change group color
ENDEMIC_colors <- setNames(c("#F1A340","#998EC3"), c("previously_exposed","primary_infected"))
#previously_exposed   primary_infected 
#         "#F1A340"          "#998EC3" 
ENDEMIC_colors <- setNames(brewer.pal(3,"PuOr")[c(1,3)], c("previously_exposed","primary_infected"))
names(ENDEMIC_colors) <- c("previously","primary")

TIME_colors <- setNames(brewer.pal(6,"PiYG"), c("Acute","D10","M1","M3","M6","Y1"))
```

## 1. PreProcessing ALL data 
```{r}
#- RNA Normalization
pbmc <- NormalizeData(object = pbmc, assay = 'RNA', normalization.method = 'LogNormalize', scale.factor = 10000)

#- Ab Normalization
pbmc <- NormalizeData(object = pbmc, assay = 'ADT', normalization.method = 'CLR') #margin	If performing CLR normalization, normalize across features (1) or cells (2)
```

```{r}
p1 <- DimPlot(pbmc, reduction = "wnn.umap",group.by = "CellType_L1" ,label = T, pt.size = 0.5, label.size = 5,repel = T) +
  NoLegend() + 
  ggplot2::labs(title = "Immune cell landscape - Level 1",
                caption = paste0("based on ",dim(pbmc)[2], " cells"))
p2 <- DimPlot(pbmc, reduction = "wnn.umap",group.by = "CellType_L2" ,label = T, pt.size = 0.5, label.size = 5,repel = T) +
  NoLegend() + 
  ggplot2::labs(title = "Immune cell landscape - Level 2",
                caption = paste0("based on ",dim(pbmc)[2], " cells"))
p1 | p2
```

## 2. B cell focus

### 2.0.1 B cell subclustering

```{r}
Idents(pbmc) <- "CellType_L1"

pbmc <- FindSubCluster(pbmc,cluster="B",subcluster.name = "PBMC_L1_B_subcluster",graph.name = "wsnn",algorithm = 3,resolution = 0.1)

(p1 <- DimPlot(pbmc,group.by = "PBMC_L1_B_subcluster", reduction = 'wnn.umap', label = TRUE, repel = TRUE, label.size = 2.5) + NoLegend() + 
    ggplot2::labs(title = "B cell subclustering "))
```

### 2.0.1 B cell subcluster markers

```{r}
Idents(pbmc) <- "PBMC_L1_B_subcluster"
PBMC_L1_B_subcluster.markers <- FindAllMarkers(pbmc,
                               min.diff.pct = 0.1,
                               only.pos = T,
                               max.cells.per.ident = 50,
                               #test.use = "MAST",
                               min.cells.feature = 20,
                               verbose = FALSE,
                               #latent.vars = c("nCount_RNA","Time","Group"),
                               assay = "RNA")
PBMC_L1_B_subcluster.markers <- PBMC_L1_B_subcluster.markers %>% filter(grepl("B_",cluster)) %>% group_by(cluster) %>% arrange(p_val_adj,desc(abs(avg_log2FC))) 
PBMC_L1_B_subcluster.markers %>% slice_head(n=3)
```

### 2.0.2 B cell subcluster visualise expression

```{r}
# Violin plot - Visualize single cell expression distributions in each cluster
temp <- subset(pbmc, cells = colnames(pbmc)[grepl("B",pbmc@meta.data[, "PBMC_L1_B_subcluster"],ignore.case = F)]) 
VlnPlot(temp, 
        group.by = "PBMC_L1_B_subcluster",
        assay = "RNA",log = F,stack = T,
        pt.size = 0.1,
        features =  c(PBMC_L1_B_subcluster.markers %>% slice_head(n=5) %>% pull(gene),"ITGAX","TBX21","NKG7","PRDM1", "XBP1", "CD3E", "CD4")) + NoLegend()

(p4 <- DoHeatmap(ScaleData(temp,vars.to.regress = "nCount_ADT",assay = "ADT",),
                assay = "ADT",
          group.by = "PBMC_L1_B_subcluster",
          features = rownames(temp@assays$ADT),
          combine = T
          ))
```

***Comment*** B cell subcluster B_1 and B_2 are ITGAX1 positive, I removed Plasma cell for subsequent analysis.

## 2.1.0 Subsetting B cell cluster

```{r}
DefaultAssay(pbmc) <- "RNA"
#Idents(pbmc) <- 
bcell <- subset(pbmc, cells = colnames(pbmc)[grepl("B_0|B_1|B_2",pbmc@meta.data[, "PBMC_L1_B_subcluster"],ignore.case = F)]) 

## L1 resolution
bcell@meta.data %>%
  as.data.table %>% # the resulting md object has one "row" per cell
  rownames_to_column("CellID")  %>% 
  group_by(PBMC_L1_B_subcluster,Group,Time) %>% 
  dplyr::count() %>% 
  arrange(PBMC_L1_B_subcluster,Time) #%>% kableExtra::kable()

## L2 resolution (based on clustering of all PBMCs)
bcell@meta.data %>%
  as.data.table %>% # the resulting md object has one "row" per cell
  rownames_to_column("CellID")  %>% 
  group_by(PBMC_L1_B_subcluster,Group,Time) %>% 
  dplyr::count() %>% 
  arrange(PBMC_L1_B_subcluster,Time) #%>% kableExtra::kable()

```

```{r}
all.genes <- rownames(bcell)

Bcell <- ScaleData(bcell, features = all.genes)
Bcell <- RunPCA(Bcell, features = all.genes)
Bcell <- FindNeighbors(Bcell, reduction = "pca", dims = 1:10)
Bcell <- FindClusters(Bcell, resolution = 0.5 , reduction = "pca")

Bcell <- RunUMAP(Bcell, dims = 1:10, reduction.name = "umap.before.B.integration")

Bcell <- RunHarmony(Bcell, 
				group.by.vars = c("orig.ident"), 
				reduction = "pca", assay.use = "RNA", reduction.save = "harmony")

Bcell <- FindNeighbors(object =Bcell, reduction = "harmony")
Bcell <- FindClusters(Bcell, resolution = 0.8)

Bcell <- RunUMAP(Bcell, reduction = "harmony", assay = "RNA", dims = 1:10, reduction.name = "umap.after.B.integration")

ElbowPlot(Bcell, reduction = "harmony" )
DimPlot(Bcell, reduction = "umap.after.B.integration", label = TRUE, repel = TRUE)
```

```{r}
# Visualization
p1 <- DimPlot(Bcell, reduction = "umap.after.B.integration", group.by = "orig.ident")
p2 <- DimPlot(Bcell, reduction = "umap.after.B.integration", label = TRUE, repel = TRUE)
p1 + p2
```

```{r umap_reint_qc}
p1 <- DimPlot(Bcell, reduction = 'umap.after.B.integration', group.by = 'Group',cols =ENDEMIC_colors,  label = F, repel = TRUE, label.size = 2.5) + NoLegend() 
p2 <- DimPlot(Bcell, reduction = 'umap.after.B.integration', group.by = 'orig.ident', label = F, repel = TRUE, label.size = 2.5) + NoLegend() 
p3 <- DimPlot(Bcell, reduction = 'umap.after.B.integration', group.by = 'Time', label = F, cols = TIME_colors, repel = TRUE, label.size = 2.5) + NoLegend() 
p1 + p2 + p3
```

### 2.1.2 Identify all cell type markers
```{r}
# find markers for every cluster compared to all remaining cells, report only the positive ones
bcell.markers <- FindAllMarkers(Bcell, only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25)
bcell.markers %>%
    group_by(cluster) %>%
    slice_max(n = 2, order_by = avg_log2FC)
```

### 2.1.5 B cell and Contamination marker
```{r}
#AtBC markers
atbc.genes <- c("ITGAX","TBX21","CXCR3", "CR2","CD24","CD27","NKG7","adt_CD27","CD1C","adt_CD11c","adt_FCRL5", "JCHAIN", "adt_CD21", "SELL")
VlnPlot(Bcell, features = atbc.genes, pt.size = 0, assay = "RNA")
Nebulosa::plot_density(Bcell, features = c("ITGAX","TBX21","CXCR3","MS4A1","NKG7","adt_CD27","CD24","adt_CD11c","adt_FCRL5", "JCHAIN", "IGKC"))
VlnPlot(Bcell, features = c("CD163", "IGHM-secreted", "NKG7", "MS4A1", "CD244", "GZMB", "PRF1","IGHM-membrane","IGHD-membrane","PRDM1", "IL32", "FCGR3A", "B3GAT1", "XBP1", "IGHA1-secreted", "CD3E", "ITGAX", "IGHG2-secreted", "IGKC", "TBX21"), pt.size = 0, assay = "RNA")

DimPlot(Bcell, reduction = "umap.after.B.integration", label = TRUE, repel = TRUE)
```

### 2.1.3 Removing cell contamination and reclustring + Find DEG
```{r}
# To subset and remove single cluster and keep the remaining clusters for new analysis, removed also clutser 6 as ID is confusing ???
subcell <- subset(Bcell, idents = c(5, 6, 7, 8, 9), invert = TRUE)

subcell <- ScaleData(subcell, features = all.genes)
subcell <- RunPCA(subcell, features = all.genes)
subcell <- FindNeighbors(object =subcell, reduction = "harmony")
subcell <- FindClusters(subcell, resolution = 0.8)
subcell <- RunUMAP(subcell, reduction = "harmony", assay = "RNA", dims = 1:15, reduction.name = "umap.after.B.integration")
DimPlot(subcell, reduction = "umap.after.B.integration", label = TRUE, repel = TRUE)
ElbowPlot(subcell, reduction = "harmony" )

subcell.markers <- FindAllMarkers(subcell, only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25)
subcell.markers %>%
    group_by(cluster) %>%
    slice_max(n = 2, order_by = avg_log2FC)

VlnPlot(subcell, features = atbc.genes, pt.size = 0, assay = "RNA")
Nebulosa::plot_density(subcell, features = c("ITGAX","TBX21","CXCR3","MS4A1","NKG7","adt_CD27","CD24","adt_CD11c","adt_FCRL5", "JCHAIN", "IGKC"))

DimPlot(subcell, group.by = "Time", reduction = "umap.after.B.integration", cols = c("grey", "red", "blue"), pt.size = 2)
DimPlot(subcell, group.by = "Group", reduction = "umap.after.B.integration", cols = c("orange", "grey"), pt.size = 2)

# Create the plot
plot <- DimPlot(subcell, 
                group.by = "Time", 
                reduction = "umap.after.B.integration", 
                cols = c("grey", "red", "blue"), 
                pt.size = 2) +
        theme(legend.text = element_text(size = 18),  # Increase legend text size
              legend.title = element_text(size = 16))  # Increase legend title size
plot
# Save the plot with high resolution
ggsave("FigS1c.pdf", plot = plot, width = 8, height = 6)

# Create the plot
plot <- DimPlot(subcell, 
                group.by = "Group", 
                reduction = "umap.after.B.integration", 
                cols = c("orange", "grey"), 
                pt.size = 2) +
        theme(legend.text = element_text(size = 18),  # Increase legend text size
              legend.title = element_text(size = 16))  # Increase legend title size
plot
# Save the plot with high resolution
#ggsave("DimPlot2_with_Larger_Legend.png", plot = plot, dpi = 300, width = 8, height = 6)

plot <- DimPlot(subcell, 
                group.by = "orig.ident", 
                reduction = "umap.after.B.integration", 
                pt.size = 2) +
        theme(legend.text = element_text(size = 18),  # Increase legend text size
              legend.title = element_text(size = 16))  # Increase legend title size
plot

ggsave("FigS1b.pdf", plot = plot, width = 8, height = 6)

```

```{r}
library(ggplot2)
library(Seurat)

# Extract UMAP data
umap_data <- as.data.frame(Embeddings(subcell, reduction = "umap.after.B.integration"))

# Extract metadata
metadata <- subcell@meta.data

# Combine UMAP coordinates with metadata
plot_data <- cbind(umap_data, metadata)

# Verify and fix Group levels
plot_data$Group <- factor(plot_data$Group, levels = c("primary", "previously"))

# Ensure no NA values in UMAP coordinates
plot_data <- plot_data[complete.cases(plot_data[, c("umapafterBintegration_1", "umapafterBintegration_2")]), ]

# Check if "Previously" group exists and add density layer conditionally
if (nrow(plot_data[plot_data$Group == "previously", ]) > 0) {
    density_layer <- geom_density_2d(data = plot_data[plot_data$Group == "previously", ],
                                     aes(x = umapafterBintegration_1, y = umapafterBintegration_2),
                                     color = "blue", size = 1)
} else {
    density_layer <- NULL
}

# Create the plot
ggplot(plot_data, aes(x = umapafterBintegration_1, y = umapafterBintegration_2)) +
  geom_point(aes(color = Group), size = 2) +
  density_layer +
  scale_color_manual(values = c("Primary" = "orange", "Previously" = "grey")) +
  labs(title = "UMAP with Density Contour", x = "UMAP 1", y = "UMAP 2")

ggplot(plot_data, aes(x = umapafterBintegration_1, y = umapafterBintegration_2)) +
  geom_point(aes(color = Group), size = 2) +
  geom_density_2d(data = plot_data[plot_data$Group == "previously", ],
                  aes(x = umapafterBintegration_1, y = umapafterBintegration_2),
                  color = "black", size = 1, bins = 6) + # Increase bins only
  scale_color_manual(values = c("primary" = "grey", "previously" = "orange")) +
  labs(title = "UMAP with Density Contour", 
       x = "UMAP 1", y = "UMAP 2") +
  theme_minimal()


library(ggplot2)

# Create the plot
umap_plot <- ggplot(plot_data, aes(x = umapafterBintegration_1, y = umapafterBintegration_2)) +
  geom_point(aes(color = Group), size = 2) +
  geom_density_2d(data = plot_data[plot_data$Group == "previously", ],
                  aes(x = umapafterBintegration_1, y = umapafterBintegration_2),
                  color = "black", size = 0.5, bins = 6) +
  scale_color_manual(values = c("primary" = "grey", "previously" = "orange")) +
  labs(title = "UMAP with Density Contour Previously", 
       x = "UMAP 1", y = "UMAP 2") +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),       # Remove grid lines
    panel.background = element_blank(), # Remove panel background
    axis.line = element_line(color = "black") # Add axis lines
  ) +
  xlim(-8, 8) + # Adjust the limits of the UMAP axes as needed
  ylim(-7, 7)   # Adjust the limits of the UMAP axes as neededx

umap_plot


umap_plot2 <- ggplot(plot_data, aes(x = umapafterBintegration_1, y = umapafterBintegration_2)) +
  geom_point(aes(color = Group), size = 2) +
  geom_density_2d(data = plot_data[plot_data$Group == "primary", ],
                  aes(x = umapafterBintegration_1, y = umapafterBintegration_2),
                  color = "black", size = 0.5, bins = 8) +
  scale_color_manual(values = c("primary" = "grey", "previously" = "orange")) +
  labs(title = "UMAP with Density Contour Primary", 
       x = "UMAP 1", y = "UMAP 2") +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),       # Remove grid lines
    panel.background = element_blank(), # Remove panel background
    axis.line = element_line(color = "black") # Add axis lines
  ) +
  xlim(-8, 8) + # Adjust the limits of the UMAP axes as needed
  ylim(-7, 7)   # Adjust the limits of the UMAP axes as neededx

umap_plot2
# Save the plot as a PNG
#ggsave("UMAP_with_density_contourPrev.png", plot = umap_plot, width = 8, height = 6, dpi = 300)
#ggsave("UMAP_with_density_contourPrim.png", plot = umap_plot2, width = 8, height = 6, dpi = 300)

```
```{r}
library(ggplot2)
library(RColorBrewer)

# Generate a color palette with the first color as white
num_colors <- 6  # Adjust this based on the number of bins
colors <- c("white", colorRampPalette(c("lightblue", "blue", "red"))(num_colors - 1))

# Find the data range to set limits dynamically
x_range <- range(plot_data$umapafterBintegration_1, na.rm = TRUE)
y_range <- range(plot_data$umapafterBintegration_2, na.rm = TRUE)
buffer <- 1  # Add a buffer to avoid tight cropping

# Create the plot
umap_plot <- ggplot(plot_data, aes(x = umapafterBintegration_1, y = umapafterBintegration_2)) +
  # Plot all cells in grey
  geom_point(color = "black", size = 1) +
  # Add gradient-filled contours for density
  geom_density_2d_filled(data = plot_data[plot_data$Group == "previously", ],
                         aes(x = umapafterBintegration_1, y = umapafterBintegration_2, fill = ..level..),
                         alpha = 0.5) +
  # Add contour lines on top of the filled regions
  geom_density_2d(data = plot_data[plot_data$Group == "previously", ],
                  aes(x = umapafterBintegration_1, y = umapafterBintegration_2),
                  color = "black", size = 0.5, bins=10) +
  # Use scale_fill_manual to map discrete levels to colors
  scale_fill_manual(values = colors, name = "Cell Density") +
  # Simplify title and axis labels
  labs(title = "Density of 'Previously' Group", 
       x = "UMAP 1", 
       y = "UMAP 2") +
  # Set axis limits dynamically
  xlim(x_range[1] - buffer, x_range[2] + buffer) +
  ylim(y_range[1] - buffer, y_range[2] + buffer) +
  # Clean up the theme
  theme_minimal() +
  theme(
    panel.grid = element_blank(),  # Remove grid
    legend.position = "right",     # Place legend on the right
    plot.title = element_text(size = 14, hjust = 0.5, face = "bold")  # Center and bold the title
  )
umap_plot
# Save the plot as PNG
#ggsave("UMAP_density_plotPrevious.pdf", plot = umap_plot, width = 8, height = 6, dpi = 300)
#ggsave("UMAP_density_plotPrevious.png", plot = umap_plot, width = 8, height = 6, dpi = 300)




library(ggplot2)
library(RColorBrewer)

# Generate a color palette with the first color as white
num_colors <- 8  # Adjust this based on the number of bins
colors <- c("white", colorRampPalette(c("lightblue", "blue", "red"))(num_colors - 1))

# Find the data range to set limits dynamically
x_range <- range(plot_data$umapafterBintegration_1, na.rm = TRUE)
y_range <- range(plot_data$umapafterBintegration_2, na.rm = TRUE)

# Add a dynamic buffer (10% of the range)
x_buffer <- 0.1 * (x_range[2] - x_range[1])
y_buffer <- 0.1 * (y_range[2] - y_range[1])

# Create the plot
umap_plot2 <- ggplot(plot_data, aes(x = umapafterBintegration_1, y = umapafterBintegration_2)) +
  # Plot all cells in grey
  geom_point(color = "black", size = 1) +
  # Add gradient-filled contours for density
  geom_density_2d_filled(data = plot_data[plot_data$Group == "primary", ],
                         aes(x = umapafterBintegration_1, y = umapafterBintegration_2, fill = ..level..),
                         alpha = 0.5) +
  # Add contour lines on top of the filled regions
  geom_density_2d(data = plot_data[plot_data$Group == "primary", ],
                  aes(x = umapafterBintegration_1, y = umapafterBintegration_2),
                  color = "black", size = 0.5, bins = 10) +
  # Use scale_fill_manual to map discrete levels to colors
  scale_fill_manual(values = colors, name = "Cell Density") +
  # Simplify title and axis labels
  labs(title = "Density of 'primary' Group", 
       x = "UMAP 1", 
       y = "UMAP 2") +
  # Set axis limits dynamically with a larger buffer
  xlim(x_range[1] - x_buffer, x_range[2] + x_buffer) +
  ylim(y_range[1] - y_buffer, y_range[2] + y_buffer) +
  # Clean up the theme
  theme_minimal() +
  theme(
    panel.grid = element_blank(),  # Remove grid
    legend.position = "right",     # Place legend on the right
    plot.title = element_text(size = 14, hjust = 0.5, face = "bold")  # Center and bold the title
  )
umap_plot2
# Save the plot as PNG and PDF
#ggsave("UMAP_density_plotPima.pdf", plot = umap_plot2, width = 8, height = 6, dpi = 300)
#ggsave("UMAP_density_plotPrima.png", plot = umap_plot2, width = 8, height = 6, dpi = 300)

```


###2.1.4 Cluster annotation and colors
```{r}
# Calculate the mean of reads per cell
mean_reads_per_cell <- mean(subcell$nCount_RNA)

# Print the mean
print(mean_reads_per_cell)

## set cluster names
subcell.cluster.ids <- c("CD21Naive", "Naive", "MBC", "NSw-MBC", "Int-AtBC", "CD11c-MBC", "Ter-AtBC")
names(subcell.cluster.ids) <- levels(subcell)
subcell <- RenameIdents(subcell, subcell.cluster.ids)

## set color for all 
subcell.idents.col <- setNames(c(RColorBrewer::brewer.pal(name="Set3",n=11)), c("CD21Naive", "Naive", "MBC", "NSw-MBC", "Int-AtBC", "CD11c-MBC", "Ter-AtBC"))

DimPlot(subcell, reduction = "umap.after.B.integration", label = TRUE, pt.size = 3,label.size = 10, cols = subcell.idents.col) + NoLegend()

DimPlot(subcell, reduction = "umap.after.B.integration", label = FALSE, pt.size = 3, cols = subcell.idents.col) + NoLegend()
plot <- DimPlot(subcell, reduction = "umap.after.B.integration", label = FALSE, pt.size = 3, cols = subcell.idents.col) + NoLegend()
ggsave("DimPlot_without_labels.pdf", plot = plot, width = 10, height = 8)


#Ig Test expression
VlnPlot(subcell, features = c("adt_IgG", "adt_IgM", "adt_IgD", "IGHD-membrane", "IGHM-membrane", "FCRL5"), pt.size = 0, cols = subcell.idents.col)
VlnPlot(subcell, features = c("IGHG1-secreted","IGHG2-secreted", "IGHG3-secreted", "IGHA1-secreted", "IGHM-secreted", "CD72"), pt.size = 0, cols = subcell.idents.col)

atbc.genes <- c("ITGAX","TBX21","CXCR3","CD24", "CD27","NKG7","CD1C", "MZB1", "adt_CD27","adt_CD11c","adt_FCRL5", "adt_CD21")
atbc.genes1 <- c("ITGAX","TBX21","CXCR3","NKG7")
atbc.genes2 <- c("CD27","NKG7","CD1C", "MZB1")
atbc.genes.surface <- c("adt_CD11c","adt_FCRL5","adt_CD27", "adt_CD21")

vlnplot_1 <- VlnPlot(subcell, features = atbc.genes1, pt.size = 0.1, idents = c("Ter-AtBC", "MBC", "Int-AtBC", "CD11c-MBC","CD21Naive", "Naive","NSw-MBC"),cols = subcell.idents.col, stack = FALSE, flip = TRUE, fill.by = "ident" )
vlnplot_1
#ggsave("VlnPlot_atbc_genes.pdf", plot = vlnplot_1, width = 8, height = 8)

vlnplot_2 <-  VlnPlot(subcell, features = atbc.genes2, pt.size = 0, idents = c("Ter-AtBC", "MBC", "Int-AtBC", "CD11c-MBC","CD21Naive", "Naive","NSw-MBC"),cols = subcell.idents.col, stack = TRUE, flip = TRUE, fill.by = "ident" )
#ggsave("VlnPlot_atbc2.pdf", plot = vlnplot_2, width = 8, height = 8)

vlnplot_3 <-  VlnPlot(subcell, features = atbc.genes.surface, pt.size = 0, idents = c("Ter-AtBC", "MBC", "Int-AtBC", "CD11c-MBC","CD21Naive", "Naive","NSw-MBC"),cols = subcell.idents.col, stack = TRUE, flip = TRUE, fill.by = "ident" )
#ggsave("VlnPlot_atbc_surface.pdf", plot = vlnplot_3, width = 8, height = 8)

vlnplot_4 <-  VlnPlot(subcell, features = atbc.genes, pt.size = 0, idents = c("Ter-AtBC", "MBC", "Int-AtBC", "CD11c-MBC","CD21Naive", "Naive","NSw-MBC"),cols = subcell.idents.col, stack = TRUE, flip = FALSE, fill.by = "ident" ) + theme(axis.text.x = element_text(angle = 0, hjust = 0.5)) 
#ggsave("VlnPlot_atbc_total.pdf", plot = vlnplot_4, width = 14, height = 6)

VlnPlot(subcell, features = c("CD24", "ICOSLG", "CD80", "CD40", "CD274", "ITGAM"), pt.size = 0, idents = c("Ter-AtBC", "Int-AtBC", "CD11c-MBC"),cols = subcell.idents.col, stack = FALSE, flip = FALSE, fill.by = "ident" )

Nebulosa::plot_density(subcell, features = c("MKI67"))
MZBgene <- c("CD1C", "MZB1", "FCER2", "EBF1", "TCF3", "PAX5")
VlnPlot(subcell, features = MZBgene, pt.size = 0,cols = subcell.idents.col, stack = FALSE, flip = FALSE, fill.by = "ident" )
#Nebulosa::plot_density(subcell, features = c("CD1C", "MZB1", "FCER2", "EBF1", "PAX5"), point_size=2)





# List of genes to plot
genes <- atbc.genes1  # Replace with your gene list

# Generate individual violin plots for each gene without legends
individual_plots <- lapply(genes, function(gene) {
  VlnPlot(
    subcell, 
    features = gene, 
    pt.size = 0, 
    idents = c("Ter-AtBC", "MBC", "Int-AtBC", "CD11c-MBC", "CD21Naive", "Naive", "NSw-MBC"),
    cols = subcell.idents.col, 
    stack = FALSE, 
    flip = TRUE, 
    fill.by = "ident"
  ) +
    theme(
      legend.position = "none",         # Remove color legend
      axis.title.y = element_blank(),  # Remove Y-axis title
      axis.text.y = element_blank()    # Remove Y-axis text
    )
})


combined_plot
# Save the combined plot as a PDF
#ggsave("Violin_Plots_2x2.pdf", plot = combined_plot, width = 12, height = 10, device = "pdf")



library(Seurat)
library(ggplot2)
library(ggpubr)

# Define gene lists
atbc.genes1 <- c("ITGAX", "TBX21", "CXCR3", "NKG7")
atbc.genes2 <- c("CD27", "CD24", "CD1C", "MZB1")
atbc.genes.surface <- c("adt_CD11c", "adt_FCRL5", "adt_CD27", "adt_CD21")

# Combine all gene lists with their column assignments
all_genes <- list(atbc.genes1, atbc.genes2, atbc.genes.surface)

# Generate violin plots for each gene list
all_plots <- lapply(seq_along(all_genes), function(i) {
  lapply(all_genes[[i]], function(gene) {
    VlnPlot(
      subcell, 
      features = gene, 
      pt.size = 0., 
      idents = c("Ter-AtBC", "MBC", "Int-AtBC", "CD11c-MBC", "CD21Naive", "Naive", "NSw-MBC"),
      cols = subcell.idents.col, 
      stack = FALSE, 
      flip = TRUE, 
      fill.by = "ident"
    ) +
      theme(
        legend.position = "none",         # Remove color legend
        axis.title.y = element_blank(),  # Remove Y-axis title
        axis.text.y = element_blank(),   # Remove Y-axis text
        axis.title.x = element_blank() # Remove X-axis title
      )
  })
})

# Arrange the plots in columns
combined_plot <- ggarrange(
  ggarrange(plotlist = all_plots[[1]], ncol = 1),  # First column
  ggarrange(plotlist = all_plots[[2]], ncol = 1),  # Second column
  ggarrange(plotlist = all_plots[[3]], ncol = 1),  # Third column
  ncol = 3
)
combined_plot
# Save the combined plot as a PDF
#ggsave("Violin_Plots_Columns_By_List.pdf", plot = combined_plot, width = 15, height = 12, device = "pdf")

# Save the combined plot as a PNG
#ggsave("Violin_Plots_Columns_By_List.png", plot = combined_plot, width = 15, height = 12, dpi = 300, device = "png")




library(Seurat)
library(Nebulosa)
library(ggpubr)

# Define gene lists
atbc.genes1 <- c("ITGAX", "TBX21", "CXCR3", "NKG7")
atbc.genes2 <- c("CD27", "NKG7", "CD1C", "MZB1")

# Generate density plots for each gene list
all_density_plots <- list(
  lapply(atbc.genes1, function(gene) {
    plot_density(
      subcell, 
      features = gene, 
      reduction = "umap.after.B.integration", size = 2
    ) +
      theme(
        legend.position = "none",         # Remove color legend
        axis.title = element_blank(),    # Remove axis titles
        axis.text = element_blank(),     # Remove axis text
      )
  }),
  lapply(atbc.genes2, function(gene) {
    plot_density(
      subcell, 
      features = gene, 
      reduction = "umap.after.B.integration", size = 2
    ) +
      theme(
        legend.position = "none",         # Remove color legend
        axis.title = element_blank(),    # Remove axis titles
        axis.text = element_blank(),     # Remove axis text
      )
  })
)

# Flatten the list of plots
all_density_plots_flat <- do.call(c, all_density_plots)

# Arrange all plots into one column
combined_density_plot <- ggarrange(plotlist = all_density_plots_flat, ncol = 1)
combined_density_plot
# Save the combined plot as a PDF
#ggsave("Density_Plots_Columns_By_List.pdf", plot = combined_density_plot, width = 12, height = 10, device = "pdf")

# Save the combined plot as a PNG
#ggsave("Density_Plots_Columns_By_List.png", plot = combined_density_plot, width = 12, height = 10, dpi = 300, device = "png")

```

```{r}
chemo.genes <- c("CCL1","CCL2","CCL3", "CCL4","CCL5","CCL7","CCL8","CCL13", "CCL14", "CCL16","CCL17", "CCL18", "CCL19", "CCL20", "CCL21", "CCL22", "CCL23","CCL27", "CCL28", "CCL3L3", "CCL4L2", "C5", "CKLF", "CXCL1", "CXCL2", "CXCL3", "CXCL4", "CXCL5", "CXCL6", "IL8", "CXCL9", "CXCL10", "CXCL11", "CXCL13", "CXCL14", "CXCL16", "CXC3CL1", "RARRES2", "PF4V1", "XCL1", "XCL2")
chemoR.genes <- c("CCR1", "CCR2", "CCR3","CCR4","CCR6","CCR7", "CCR10","CCR12","CMKLR1","CXCR3","CXCR4", "CXCR5", "DARC","ACKR2", "ACKR3", "ACKR4")
integrin.genes <- c("ITGA1","ITGA2","ITGA2B", "ITGA3","ITGA5","ITGA6","ITGA9","ITGAV", "ITGB1", "ITGB2","ITGB3", "ITGB4", "ITGB5")
CytoRec.genes <- c("VEGFA","VEGFB","VEGFC", "FLT4","PDGFRA","PDGFRB","IL7","IL2RG", "IL3RA", "CSF2RB","TIMP1", "IL6", "LIF", "IL6ST", "IL1RA", "LIFR", "OSMR","IFNGR1", "IFNGR2", "IL33", "LTA", "LTB", "TNF", "TNFSF9", "TNFSF10", "TNFSF11", "TNFSF12", "TNFSF13B", "CD40", "TNFRSF1A", "TNFRSF4", "TNFRSF9", "BMP2", "BMP4", "GDF10", "TGFB1", "TGFB2", "TGFBR2", "CSF1", "FAM3C", "GRN", "IL32", "IL34", "NAMPT")
MBCAtBC <- c("NKG7","TBX21","IGHM-membrane", "IGHM-secreted", "IGHD-membrane", "CD72", "SELL", "CXCR5", "CD24", "CD27", "CD1C", "BIRC3", "MYC", "NT5E", "IGHA1-secreted", "S100A10","JCHAIN", "CD86", "FAS", "CD40", "CD44", "ITGAM")

#DotPlot(My_object, features = atbc.genes, cols = brewer.pal(3, "Pastel1"), dot.scale = 10 ) + RotatedAxis() + ggtitle("AtBC genes")
DotPlot(subcell, features = chemo.genes, cols = brewer.pal(3, "Pastel1"), dot.scale = 10 ) + RotatedAxis() + ggtitle("Chemokines genes")
DotPlot(subcell, features = chemoR.genes, cols = brewer.pal(3, "Pastel1"), dot.scale = 10 ) + RotatedAxis() + ggtitle("Chemokines receptor genes")
DotPlot(subcell, features = integrin.genes, cols = brewer.pal(3, "Pastel1"), dot.scale = 10 ) + RotatedAxis() + ggtitle("Integrin genes")
DotPlot(subcell, features = CytoRec.genes, cols = brewer.pal(3, "Pastel1"), dot.scale = 10 ) + RotatedAxis() + ggtitle("Cytokines and Receptor genes")
dotplot_figure <- DotPlot(subcell,features = MBCAtBC, dot.scale = 10, idents = c("Ter-AtBC", "Int-AtBC", "CD11c-MBC", "MBC", "NSw-MBC"), cols = "RdYlBu" ) + RotatedAxis() + ggtitle("Atypical clusters DEG")


ggsave("AtBCDotPlot.pdf", plot = dotplot_figure, width = 10, height = 4)
ggsave("AtBCDotPlot.png", plot = dotplot_figure, width = 10, height = 4)

DotPlot(subcell, features = MBCAtBC, dot.scale = 10, idents = c("Ter-AtBC", "MBC", "Int-AtBC", "CD11c-MBC", "NSw-MBC"), cols = "RdYlBu" ) + RotatedAxis() + ggtitle("Atypical clusters DEG")

genes_to_plot <- c(
  "TCL1A",    # Naive
  "IGHD-membrane",     # Naive
  "IGHM-membrane",     # Naive/unswitched memory
  "CD27",     # Classical memory
  "CD24",     # Higher in naive
  "CD38",     # Higher in naive
  "CR2"    # Often higher in naive
)

dotplot <- DotPlot(subcell, features = genes_to_plot, cols ="RdYlBu", dot.scale = 10 ) + RotatedAxis() + ggtitle("Naive vs Classical Memory B Cell Markers")
ggsave("FigS1d.pdf", plot = dotplot, width = 10, height = 6)
```


```{r umap_reint_qc}
p1 <- DimPlot(subcell, reduction = 'umap.after.B.integration', group.by = 'Group',cols =ENDEMIC_colors,  label = F, repel = TRUE, label.size = 2.5) 
p2 <- DimPlot(subcell, reduction = 'umap.after.B.integration', group.by = 'orig.ident', label = F, repel = TRUE, label.size = 2.5)
p3 <- DimPlot(subcell, reduction = 'umap.after.B.integration', group.by = 'Time', label = F, cols = TIME_colors, repel = TRUE, label.size = 2.5)
p1 + p2 + p3
```


```{r}
# Load cell cycle genes
cc.genes <- Seurat::cc.genes

# Optionally split the genes into S and G2M phase genes
s.genes <- cc.genes$s.genes
g2m.genes <- cc.genes$g2m.genes

# Filter S and G2M genes to include only those present in the dataset
s.genes.filtered <- s.genes[s.genes %in% rownames(subcell)]
g2m.genes.filtered <- g2m.genes[g2m.genes %in% rownames(subcell)]

# Check the filtered gene lists
length(s.genes.filtered)
length(g2m.genes.filtered)


# Score the cells in the Seurat object
# Run CellCycleScoring with filtered gene sets
subcell <- CellCycleScoring(subcell, s.features = s.genes.filtered, g2m.features = g2m.genes.filtered, set.ident = TRUE)

# Perform clustering (if not already done)
#subcell <- FindClusters(subcell, resolution = 0.5)

# Calculate average cell cycle scores per cluster
cluster_cycle_scores <- subcell@meta.data %>%
  group_by(seurat_clusters) %>%
  summarize(Avg_S_Score = mean(S.Score),
            Avg_G2M_Score = mean(G2M.Score),
            Most_Common_Phase = names(sort(table(Phase), decreasing = TRUE)[1]))

print(cluster_cycle_scores)

# Optionally, visualize the average cell cycle scores using a bar plot
library(ggplot2)

ggplot(cluster_cycle_scores, aes(x = factor(seurat_clusters), y = Avg_S_Score)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  theme_minimal() +
  labs(title = "Average S Phase Score per Cluster", x = "Cluster", y = "Average S Score")

ggplot(cluster_cycle_scores, aes(x = factor(seurat_clusters), y = Avg_G2M_Score)) +
  geom_bar(stat = "identity", fill = "salmon") +
  theme_minimal() +
  labs(title = "Average G2M Phase Score per Cluster", x = "Cluster", y = "Average G2M Score")

```


###2.1.5 Heatmap
```{r}
subcell.markers %>%
    group_by(cluster) %>%
    dplyr::filter(avg_log2FC > 1) %>%
    slice_head(n = 10) %>%
    ungroup() -> top10

toplot_gene<- top10$gene
mat<- Bcell[["RNA"]]@data[toplot_gene, ] %>% as.matrix()
mat<- t(scale(t(mat)))
head(mat)

cluster_anno<- Bcell@meta.data$seurat_clusters
head(Bcell@meta.data)

myCol <- brewer.pal(9, "YlGnBu")
myBreaks <- seq(-2, 2, length.out = 50)

Heatmap(mat, name = "Expression",  
        column_split = factor(cluster_anno, levels = c(0,1,2,3,4,5,6)),
        cluster_columns = FALSE,
        show_column_dend = FALSE,
        cluster_column_slices = FALSE,
        column_title_gp = gpar(fontsize = 8),
        column_gap = unit(0.5, "mm"),
        cluster_rows = FALSE,
        show_row_dend = FALSE,
        col = myCol,
        row_names_gp = gpar(fontsize = 6),
        column_title_rot = 90,
        top_annotation = HeatmapAnnotation(foo = anno_block(gp = gpar(fill = scales::hue_pal()(9)))),
        show_column_names = FALSE,
        use_raster = TRUE)

subcell.markers %>%
    group_by(cluster) %>%
    top_n(n = 10, wt = avg_log2FC) -> top10

heatmap <- DoHeatmap(subcell, 
                     features = top10$gene, 
                     group.colors = subcell.idents.col) +
           scale_fill_viridis(option = "A") +
           theme(plot.margin = unit(c(1.5, 1, 1, 1), "cm"))  # top, right, bottom, left

# Save as PDF
ggsave("FigS1e.pdf", plot = heatmap, width = 10, height = 8)

```
###2.1.6 Volcano plot Int-AtBC VS Ter-AtBC
```{r}

MBC2vsAtBC <- FindMarkers(subcell, ident.1 = c("Int-AtBC"), ident.2 = c("Ter-AtBC"), only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25)
IntvsCD11cMBC <- FindMarkers(subcell, ident.1 = c("Int-AtBC"), ident.2 = c("CD11c-MBC"), only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25)
TerAtBCvsCD11cMBC <- FindMarkers(subcell, ident.1 = c("Ter-AtBC"), ident.2 = c("CD11c-MBC"), only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25)

volcano <- EnhancedVolcano(MBC2vsAtBC,
    lab = rownames(MBC2vsAtBC),
    x = 'avg_log2FC',
    y = 'p_val_adj',
    selectLab = c("NKG7", "SELL", "CXCR5", "CD24", "CD27", "CD1C", "BIRC3", "MYC"),
    xlab = bquote(~Log[2]~ 'fold change'),
    pointSize = 3.0,
    labSize = 6.0,
    labCol = 'black',
    labFace = 'bold',
    boxedLabels = TRUE,
    col = c('black', 'pink', 'purple', 'red3'),
    colAlpha = 4/5,
    legendPosition = 'right',
    legendLabSize = 12,
    legendIconSize = 2.0,
    drawConnectors = TRUE,
    widthConnectors = 1.0,
    colConnectors = 'black',
    title = 'Int-AtBC VS Ter-AtBC')
ggsave("FigS2a.pdf", plot = volcano, width = 10, height = 8)

volcano <- EnhancedVolcano(IntvsCD11cMBC,
    lab = rownames(IntvsCD11cMBC),
    x = 'avg_log2FC',
    y = 'p_val_adj',
    selectLab = c("IGHM-membrane", "IGHM-secreted", "IGHD-membrane", "NT5E", "IGHA1-secreted", "CD72", "TBX21", "S100A10","JCHAIN", "CD1C", "CD86", "FAS"),
    xlab = bquote(~Log[2]~ 'fold change'),
    pointSize = 3.0,
    labSize = 6.0,
    labCol = 'black',
    labFace = 'bold',
    boxedLabels = TRUE,
    col = c('black', 'pink', 'purple', 'red3'),
    colAlpha = 4/5,
    legendPosition = 'right',
    legendLabSize = 12,
    legendIconSize = 2.0,
    drawConnectors = TRUE,
    widthConnectors = 1.0,
    colConnectors = 'black',
    title = 'Int-AtBC VS CD11c-MBC')
ggsave("FigS2b.pdf", plot = volcano, width = 10, height = 8)

volcano <- EnhancedVolcano(TerAtBCvsCD11cMBC,
    lab = rownames(TerAtBCvsCD11cMBC),
    x = 'avg_log2FC',
    y = 'p_val_adj',
    xlab = bquote(~Log[2]~ 'fold change'),
    pointSize = 3.0,
    labSize = 6.0,
    labCol = 'black',
    labFace = 'bold',
    boxedLabels = TRUE,
    col = c('black', 'pink', 'purple', 'red3'),
    colAlpha = 4/5,
    legendPosition = 'right',
    legendLabSize = 12,
    legendIconSize = 2.0,
    drawConnectors = TRUE,
    widthConnectors = 1.0,
    colConnectors = 'black',
    title = 'Ter-AtBC VS CD11c-MBC')
ggsave("FigS2c.pdf", plot = volcano, width = 10, height = 8)
# Save as PDF
#ggsave("output_plot.pdf", plot = EV1)

```


```{r}
BiocManager::install("pcaMethods")
install.packages("remotes")
remotes::install_github("velocyto-team/velocyto.R")
install.packages("/path/to/velocyto.R_0.6.tar.gz", repos = NULL, type = "source")

library(Seurat)
library(velocyto.R)
library(SeuratWrappers)

# If you don't have velocyto's example mouse bone marrow dataset, download with the CURL command
# curl::curl_download(url = 'http://pklab.med.harvard.edu/velocyto/mouseBM/SCG71.loom', destfile
# = '~/Downloads/SCG71.loom')

bm <- SCTransform(object = subcell, assay = "RNA")
bm <- RunPCA(object = bm, verbose = FALSE)
bm <- FindNeighbors(object = bm, dims = 1:20)
bm <- FindClusters(object = bm)
bm <- RunUMAP(object = bm, dims = 1:20)
bm <- RunVelocity(object = bm, deltaT = 1, kCells = 25, fit.quantile = 0.02)
ident.colors <- (scales::hue_pal())(n = length(x = levels(x = bm)))
names(x = ident.colors) <- levels(x = bm)
cell.colors <- ident.colors[Idents(object = bm)]
names(x = cell.colors) <- colnames(x = bm)
show.velocity.on.embedding.cor(emb = Embeddings(object = bm, reduction = "umap"), vel = Tool(object = bm, 
    slot = "RunVelocity"), n = 200, scale = "sqrt", cell.colors = ac(x = cell.colors, alpha = 0.5), 
    cex = 0.8, arrow.scale = 3, show.grid.flow = TRUE, min.grid.cell.mass = 0.5, grid.n = 40, arrow.lwd = 1, 
    do.par = FALSE, cell.border.alpha = 0.1)
```


## 3. Pseudotime Slinglshot analysis
```{r}
#library(dyno)
#guidelines <- guidelines_shiny(subcell)

dimred <- subcell@reductions$umap.after.B.integration@cell.embeddings
clustering <- subcell$seurat_clusters
counts <- as.matrix(subcell@assays$RNA@counts[subcell@assays$RNA@var.features, ])

set.seed(1)

lineages <- getLineages(
  data =dimred,
  clusterLabels= clustering,
  reducedDim = NULL,
  start.clus = NULL,
  end.clus = NULL,
  dist.method = "slingshot",
  use.median = FALSE,
  omega = FALSE,
  omega_scale = 1.5,
  times = NULL,
)

print(lineages)

SlingshotDataSet(lineages)

# Define a color pallete to use
pal <- subcell.idents.col

sds <- as.SlingshotDataSet(lineages)

# Plot the lineages
curves <- getCurves(sds, approx_points = 300, thresh = 0.01, stretch = 0.8, allow.breaks = FALSE, shrink = 0.99)
sdc <- as.SlingshotDataSet(curves)
sdc

plot(dimred, col = pal[clustering], asp = 1, pch = 16)
lines(sdc, lwd = 3, col = "black")
```


```{r}
# Get pseudotime values for each lineage
pseudotime <- slingPseudotime(sdc)

# Normalize pseudotime values for better visualization
pseudotime <- apply(pseudotime, 2, function(x) (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))

# Create a color palette for pseudotime
color_palette <- colorRampPalette(c("darkblue", "green", "yellow"))

# Assign colors based on pseudotime for each lineage
lineage_colors <- lapply(1:ncol(pseudotime), function(i) {
  pseudotime_values <- pseudotime[, i]
  color_palette(100)[as.numeric(cut(pseudotime_values, breaks = 100))]
})

# Plot UMAP with pseudotime colors
plot(dimred, col = "white", asp = 1, pch = 16, xlab = "UMAP 1", ylab = "UMAP 2")

# Overlay pseudotime colors for each lineage
for (i in 1:length(lineage_colors)) {
  points(dimred, col = lineage_colors[[i]], pch = 16, cex = 0.5)
}

# Add lineage curves
lines(sdc, lwd = 3, col = "black")






# Get pseudotime values for each lineage
pseudotime <- slingPseudotime(sdc)

# Normalize pseudotime values for better visualization
pseudotime <- apply(pseudotime, 2, function(x) (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE)))

# Create a color palette for pseudotime
color_palette <- colorRampPalette(c("darkblue", "green", "yellow"))

# Assign colors based on pseudotime for each lineage
lineage_colors <- lapply(1:ncol(pseudotime), function(i) {
  pseudotime_values <- pseudotime[, i]
  color_palette(100)[as.numeric(cut(pseudotime_values, breaks = 100))]
})

# Define plotting layout: one row for the UMAP plot and one for the legend
layout(matrix(c(1, 2), nrow = 2), heights = c(4, 1)) 

# Plot the UMAP with pseudotime colors
par(mar = c(4, 4, 2, 2))  # Adjust margins for the UMAP plot
plot(dimred, col = "white", asp = 1, pch = 16, xlab = "UMAP 1", ylab = "UMAP 2")

# Overlay pseudotime colors for each lineage
for (i in 1:length(lineage_colors)) {
  points(dimred, col = lineage_colors[[i]], pch = 16, cex = 0.5)
}

# Add lineage curves
lines(sdc, lwd = 3, col = "black")

# Add pseudotime legend below the UMAP plot
par(mar = c(2, 4, 0, 2))  # Adjust margins for the legend
legend_gradient <- color_palette(100)
image(
  x = seq(0, 1, length.out = 100), y = 1,
  z = matrix(seq(0, 1, length.out = 100), ncol = 1),
  col = legend_gradient, axes = FALSE, xlab = "Pseudotime", ylab = "", add = FALSE
)
axis(1, at = seq(0, 1, length.out = 5), labels = seq(0, 1, length.out = 5), line = 0, cex.axis = 0.8)


```


```{r}
library(ggplot2)

# Convert dimred to a data frame
dimred_df <- as.data.frame(dimred)
colnames(dimred_df) <- c("UMAP1", "UMAP2")

# Add pseudotime values for each lineage to the data frame
dimred_df$pseudotime1 <- pseudotime[, 1]
dimred_df$pseudotime2 <- pseudotime[, 2]

# Use the average pseudotime for points
dimred_df$avg_pseudotime <- rowMeans(pseudotime, na.rm = TRUE)

# Convert lineage curves to a data frame
lineage_curves <- data.frame()
for (i in 1:length(sdc@curves)) {
  curve <- as.data.frame(sdc@curves[[i]]$s)
  curve$Lineage <- paste0("Lineage ", i)
  lineage_curves <- rbind(lineage_curves, curve)
}
colnames(lineage_curves) <- c("UMAP1", "UMAP2", "Lineage")

# Create the UMAP plot
umap_plot <- ggplot() +
  # Plot pseudotime points using fill
  geom_point(data = dimred_df, aes(x = UMAP1, y = UMAP2, fill = avg_pseudotime), size = 3, shape = 21, color = "NA" ) +
  scale_fill_gradientn(colors = color_palette(100), name = "Pseudotime") +
  # Add lineage curves using color
  geom_path(data = lineage_curves, aes(x = UMAP1, y = UMAP2, color = Lineage, group = Lineage), size = 2, inherit.aes = FALSE) +
  scale_color_manual(values = c("Lineage 1" = "blue", "Lineage 2" = "red")) +
  theme_minimal() +
  theme(
    panel.grid = element_blank(),  # Remove the grid
    legend.position = "bottom"
  ) +
  labs(x = "UMAP 1", y = "UMAP 2")

# Save the plot
ggsave("UMAP_with_pseudotime.pdf", umap_plot, width = 8, height = 6)
ggsave("UMAP_with_pseudotime.png", umap_plot, width = 8, height = 6, dpi = 300)


```


```{r}
BiocParallel::register(BiocParallel::SerialParam())

expression_data <- as.matrix(subcell@assays$RNA@counts)
dim(expression_data)

sce <- fitGAM(counts = expression_data, sds = curves)

plotGeneCount(curves, expression_data, clusters = clustering, models = sce)
```

```{r}
# Define function to plot
library(dplyr)
plot_differential_expression <- function(feature_id) {
    feature_id <- pseudotime_association %>% filter(pvalue < 0.05) %>% top_n(1, -waldStat) %>% pull(feature_id)
    cowplot::plot_grid(plotGeneCount(curves, expression_data, gene = feature_id[1], clusters = clustering, models = sce) + ggplot2::theme(legend.position = "none"), 
        plotSmoothers(sce, expression_data, gene = feature_id[1]))
}

pseudotime_association <- associationTest(sce)
pseudotime_association$fdr <- p.adjust(pseudotime_association$pvalue, method = "fdr")
pseudotime_association <- pseudotime_association[order(pseudotime_association$pvalue), ]
pseudotime_association$feature_id <- rownames(pseudotime_association)

feature_id <- pseudotime_association %>% filter(pvalue < 0.05) %>% top_n(1, -waldStat) %>% pull(feature_id)
plot_differential_expression(feature_id)


#Something wrong with plot as there are alway the same. CCL5 seems to be the gene with Highest chage in pseudotime overall
```

```{r}
assoRes <- associationTest(sce)
head(assoRes)

#Gene with highest change when comparing start and end points
startRes <- startVsEndTest(sce)

oStart <- order(startRes$waldStat, decreasing = TRUE)
sigGeneStart <- names(sce)[oStart[4]]
plotSmoothers(sce, expression_data, gene = sigGeneStart)
plotGeneCount(curves, expression_data, gene = sigGeneStart)
```

```{r}
#tradeSeq can discover marker genes for the differentiated cell types by comparing the average expression between end points of the lineage-specific smoothers.
endRes <- diffEndTest(sce)
o <- order(endRes$waldStat, decreasing = TRUE)
sigGene <- names(sce)[o[3]]
#plotSmoothers(sce, expression_data, sigGene)
#plotGeneCount(curves, expression_data, gene = sigGene)



# Run patternTest to get expression patterns over pseudotime
patternRes <- patternTest(sce)

# Optionally, look at the top-ranked genes
oPat <- order(patternRes$waldStat, decreasing = TRUE)
top_genes <- head(rownames(patternRes)[oPat])  # Top-ranked genes
#print(top_genes)

# Manually select the gene of interest
selected_gene <- "JCHAIN"  # Replace with the gene you want to analyze

# Ensure the gene exists in your dataset
if (selected_gene %in% rownames(expression_data)) {
  # Plot smoothed expression of the selected gene over pseudotime
  plotSmoothers(sce, expression_data, gene = selected_gene)
  
  # Plot gene counts for the selected gene along pseudotime
  plotGeneCount(curves, expression_data, gene = selected_gene)
} else {
  message("Selected gene not found in expression data.")
}
gene_count_plot <- plotGeneCount(curves, expression_data, gene = selected_gene)
ggsave("FigJCHAIN.pdf", plot = gene_count_plot, width = 10, height = 6)

# Display the plot explicitly
print(plotSmoothers(sce, expression_data, gene = selected_gene))


# Manually select the gene of interest
selected_gene <- "S100A10"  # Replace with the gene you want to analyze

# Ensure the gene exists in your dataset
if (selected_gene %in% rownames(expression_data)) {
  # Plot smoothed expression of the selected gene over pseudotime
  plotSmoothers(sce, expression_data, gene = selected_gene)
  
  # Plot gene counts for the selected gene along pseudotime
  plotGeneCount(curves, expression_data, gene = selected_gene)
} else {
  message("Selected gene not found in expression data.")
}
gene_count_plot <- plotGeneCount(curves, expression_data, gene = selected_gene)
ggsave("FigS2S100A10.pdf", plot = gene_count_plot, width = 10, height = 6)

# Display the plot explicitly
print(plotSmoothers(sce, expression_data, gene = selected_gene))


# Manually select the gene of interest
selected_gene <- "SELL"  # Replace with the gene you want to analyze

# Ensure the gene exists in your dataset
if (selected_gene %in% rownames(expression_data)) {
  # Plot smoothed expression of the selected gene over pseudotime
  plotSmoothers(sce, expression_data, gene = selected_gene)
  
  # Plot gene counts for the selected gene along pseudotime
  plotGeneCount(curves, expression_data, gene = selected_gene)
} else {
  message("Selected gene not found in expression data.")
}
gene_count_plot <- plotGeneCount(curves, expression_data, gene = selected_gene)
ggsave("FigS2SELL.pdf", plot = gene_count_plot, width = 10, height = 6)

# Display the plot explicitly
print(plotSmoothers(sce, expression_data, gene = selected_gene))


# Manually select the gene of interest
selected_gene <- "GAPDH"  # Replace with the gene you want to analyze

# Ensure the gene exists in your dataset
if (selected_gene %in% rownames(expression_data)) {
  # Plot smoothed expression of the selected gene over pseudotime
  plotSmoothers(sce, expression_data, gene = selected_gene)
  
  # Plot gene counts for the selected gene along pseudotime
  plotGeneCount(curves, expression_data, gene = selected_gene)
} else {
  message("Selected gene not found in expression data.")
}
gene_count_plot <- plotGeneCount(curves, expression_data, gene = selected_gene)
ggsave("FigS2GAPDH.pdf", plot = gene_count_plot, width = 10, height = 6)

# Display the plot explicitly
print(plotSmoothers(sce, expression_data, gene = selected_gene))

# Manually select the gene of interest
selected_gene <- "POU2AF1"  # Replace with the gene you want to analyze

# Ensure the gene exists in your dataset
if (selected_gene %in% rownames(expression_data)) {
  # Plot smoothed expression of the selected gene over pseudotime
  plotSmoothers(sce, expression_data, gene = selected_gene)
  
  # Plot gene counts for the selected gene along pseudotime
  plotGeneCount(curves, expression_data, gene = selected_gene)
} else {
  message("Selected gene not found in expression data.")
}

gene_count_plot <- plotGeneCount(curves, expression_data, gene = selected_gene)
ggsave("FigS2POU2AF1.pdf", plot = gene_count_plot, width = 10, height = 6)

# Display the plot explicitly
print(plotSmoothers(sce, expression_data, gene = selected_gene))


```

```{r}
#Discovering genes with different expression patterns, Asides from testing at the level of the differentiated cell type, researchers may be interested in assessing the expression pattern of a gene over pseudotime
patternRes <- patternTest(sce)
oPat <- order(patternRes$waldStat, decreasing = TRUE)
head(rownames(patternRes)[oPat])

plotSmoothers(sce, expression_data, gene = rownames(patternRes)[oPat][6])
plotGeneCount(curves, expression_data, gene = rownames(patternRes)[oPat][6])



library(ggplot2)

# Define the selected gene
selected_gene <- "ITGAM"

# Check if the gene exists
if (selected_gene %in% rownames(expression_data)) {
  # Generate and save the smoother plot
  smoother_plot <- plotSmoothers(sce, expression_data, gene = selected_gene)
  ggsave("plot_smootherITGAM.png", smoother_plot, width = 8, height = 6, dpi = 300, bg = "white")
  
  # Generate and save the gene count plot
  gene_count_plot <- plotGeneCount(curves, expression_data, gene = selected_gene)
  ggsave("plot_gene_countITGAM.pdf", gene_count_plot, width = 8, height = 6, dpi = 300, bg = "white")
  
  message("Plots saved successfully.")
} else {
  stop("Selected gene not found in expression data.")
}


```
##4 Reactome pathway analysis
```{r}

gsva_result <- analyse_sc_clusters(subcell, verbose = TRUE)
gsva_result
pathway_expression <- pathways(gsva_result)

# simplify the column names by removing the default dataset identifier
colnames(pathway_expression) <- gsub("\\.Seurat", "", colnames(pathway_expression))
pathway_expression[1:3,]

# find the maximum differently expressed pathway
max_difference <- do.call(rbind, apply(pathway_expression, 1, function(row) {
    values <- as.numeric(row[2:length(row)])
    return(data.frame(name = row[1], min = min(values), max = max(values)))
}))

max_difference$diff <- max_difference$max - max_difference$min

# sort based on the difference
max_difference <- max_difference[order(max_difference$diff, decreasing = T), ]

head(max_difference)

plot_gsva_pathway(gsva_result, pathway_id = rownames(max_difference)[1])

# Additional parameters are directly passed to gplots heatmap.2 function
plot_gsva_heatmap(gsva_result, max_pathways = 15, margins = c(6,20))

# limit to selected B cell related pathways
relevant_pathways <- c("R-HSA-983170", "R-HSA-388841", "R-HSA-2132295", "R-HSA-983705", "R-HSA-5690714", "R-HSA-1169091", "R-HSA-1168372", "R-HSA-983695", "R-HSA-9020958", "R-HSA-877300", "R-HSA-975110", "R-HSA-2173789", "R-HSA-1059683", "R-HSA-109606", "R-HSA-170834")
AgPres_pathways <- c("R-HSA-1236975", "R-HSA-2132295", "R-HSA-983169", "R-HSA-1236978", "R-HSA-1236973", "R-HSA-983168")
Complement_pathways <- c("R-HSA-166658", "R-HSA-977606", "R-HSA-173736", "R-HSA-166663", "R-HSA-166786", "R-HSA-166662", "R-HSA-173623","R-HSA-174577")
CellCycle_pathways <- c("R-HSA-1640170", "R-HSA-69206", "R-HSA-69615", "R-HSA-68911","R-HSA-69236", "R-HSA-453274", "R-HSA-1538133")
Activation_pathways <- c("R-HSA-983705", "R-HSA-168181", "R-HSA-168138", "R-HSA-877300","R-HSA-9020702", "R-HSA-9020558", "R-HSA-512988", "R-HSA-1059683", "R-HSA-1266695", "R-HSA-6783783","R-HSA-9020591", "R-HSA-448424", "R-HSA-9020958")

plot_gsva_heatmap(gsva_result, 
                  pathway_ids = relevant_pathways, # limit to these pathways
                  margins = c(6,30), # adapt the figure margins in heatmap.2
                  dendrogram = "col", # only plot column dendrogram
                  scale = "row", # scale for each pathway
                  key = TRUE, # don't display the color key
                  lwid=c(0.1,0.5)) # remove the white space on the left

plot_gsva_heatmap(gsva_result, 
                  pathway_ids = AgPres_pathways, # limit to these pathways
                  truncate_names=FALSE,
                  margins = c(6,30), # adapt the figure margins in heatmap.2
                  dendrogram = "col", # only plot column dendrogram
                  scale = "row", # scale for each pathway
                  key = TRUE, # don't display the color key
                  lwid=c(0.1,0.5)) # remove the white space on the left

plot_gsva_heatmap(gsva_result, 
                  pathway_ids = Complement_pathways, # limit to these pathways
                  truncate_names=FALSE,
                  margins = c(6,30), # adapt the figure margins in heatmap.2
                  dendrogram = "col", # only plot column dendrogram
                  scale = "row", # scale for each pathway
                  key = TRUE, # don't display the color key
                  lwid=c(0.1,0.5)) # remove the white space on the left

plot_gsva_heatmap(gsva_result, 
                  pathway_ids = CellCycle_pathways, # limit to these pathways
                  truncate_names=FALSE,
                  margins = c(6,30), # adapt the figure margins in heatmap.2
                  dendrogram = "col", # only plot column dendrogram
                  scale = "row", # scale for each pathway
                  key = TRUE, # don't display the color key
                  lwid=c(0.1,0.5)) # remove the white space on the left

plot_gsva_heatmap(gsva_result, 
                  pathway_ids = Activation_pathways, # limit to these pathways
                  truncate_names=FALSE,
                  margins = c(6,30), # adapt the figure margins in heatmap.2
                  dendrogram = "col", # only plot column dendrogram
                  scale = "row", # scale for each pathway
                  key = TRUE, # don't display the color key
                  lwid=c(0.1,0.5)) # remove the white space on the left

plot_gsva_pathway(gsva_result, "R-HSA-1640170")
plot_gsva_pathway(gsva_result, "R-HSA-69615")

plot_gsva_pca(gsva_result)

```

## 5 Cell surface exp
```{r}
(p4 <- DoHeatmap(ScaleData(subcell,vars.to.regress = "nCount_ADT",assay = "ADT",),
                assay = "ADT",
          group.by = "ident",
          features = rownames(subcell@assays$ADT),
          combine = T
          ))+ scale_fill_viridis()

DoHeatmap(
  ScaleData(subcell, vars.to.regress = "nCount_ADT", assay = "ADT"),
  assay = "ADT",
  group.by = "ident",
  group.colors = subcell.idents.col,
  features = rownames(subcell@assays$ADT),
  combine = TRUE
) + 
  scale_fill_viridis_c(option = "B")




# Define features to use, excluding specific ones
#CD123, CD127, CD14, CD16, CD197 CD3, CD33, CD4, CD56, CD8, TCR-gamma-delta TCR-Vdelta2
features_to_plot <- setdiff(rownames(subcell@assays$ADT), c("CD123", "CD127", "CD14", "CD16", "CD197", "CD3", "CD33", "CD4", "CD56", "CD8", "TCR-gamma-delta", "TCR-Vdelta2"))

# Create heatmap with extra top margin
heatmap <- DoHeatmap(
  ScaleData(subcell, vars.to.regress = "nCount_ADT", assay = "ADT"),
  assay = "ADT",
  group.by = "ident",
  group.colors = subcell.idents.col,
  features = features_to_plot,
  combine = TRUE
) + 
  scale_fill_viridis_c(option = "B") +
  theme(plot.margin = unit(c(2, 1, 1, 1), "cm"))  # top, right, bottom, left

# Save if needed
ggsave("FigS1f.pdf", plot = heatmap, width = 10, height = 8)
```

## 6 Go enrichment analysis
```{r}
library(clusterProfiler)
# 1. Identify differentially expressed genes
de_genes <- FindMarkers(subcell, ident.1 = "Int-AtBC", ident.2 = "Ter-AtBC", key.by = "SYMBOL")
gene_names <- rownames(de_genes)
de_genes$gene <- gene_names

gene_list <- de_genes$gene

# Perform Gene Ontology enrichment analysis
go_enrichment <- enrichGO(gene = gene_list,
                          OrgDb = org.Hs.eg.db,  # Replace with the appropriate organism database
                          keyType = "SYMBOL",
                          ont = "all",  # Biological Process (BP), use "CC" for Cellular Component, "MF" for Molecular Function
                          pvalueCutoff = 0.05,
                          qvalueCutoff = 0.2,
                          readable = TRUE)

dotplot(go_enrichment, showCategory = 5, split="ONTOLOGY") + facet_grid(ONTOLOGY~., scale="free")

# Extract DEGs for each cluster
cluster_DEGs <- lapply(unique(subcell.markers$cluster), function(cluster_id) {
  de_genes_subset <- subcell.markers[subcell.markers$cluster == cluster_id, ]
  return(de_genes_subset)
})

# 1. Identify differentially expressed genes
de_genes <- FindMarkers(subcell, ident.1 = "CD11c-MBC", ident.2 = "Ter-AtBC", key.by = "SYMBOL")
gene_names <- rownames(de_genes)
de_genes$gene <- gene_names

gene_list <- de_genes$gene

# Perform Gene Ontology enrichment analysis
go_enrichment <- enrichGO(gene = gene_list,
                          OrgDb = org.Hs.eg.db,  # Replace with the appropriate organism database
                          keyType = "SYMBOL",
                          ont = "all",  # Biological Process (BP), use "CC" for Cellular Component, "MF" for Molecular Function
                          pvalueCutoff = 0.05,
                          qvalueCutoff = 0.2,
                          readable = TRUE)

dotplot(go_enrichment, showCategory = 5, split="ONTOLOGY") + facet_grid(ONTOLOGY~., scale="free")

# Extract DEGs for each cluster
cluster_DEGs <- lapply(unique(subcell.markers$cluster), function(cluster_id) {
  de_genes_subset <- subcell.markers[subcell.markers$cluster == cluster_id, ]
  return(de_genes_subset)
})
```


# === alluvial plot ===
```{r}
## add identity information to meta.data

subcell<- AddMetaData(
  object = subcell,
  metadata = Idents(subcell),
  col.name = 'subcell.idents'
)

tibble(subcell@meta.data)
```

```{r}
require(ggalluvial)

theme_mjl_alluvial <- theme(axis.line=element_blank(),
      axis.text.x= element_text(size=18),# element_blank(),
      axis.text.y=element_blank(),
      axis.ticks=element_blank(),
      axis.title.x=element_blank(),
      axis.title.y=element_blank(),
      legend.position="left",
      panel.background=element_blank(),
      panel.border=element_blank(),
      panel.grid.major=element_blank(),
      panel.grid.minor=element_blank(),
      plot.background=element_blank())

levels(subcell@active.ident)
## set color for all 
subcell.idents.col <- setNames(c(RColorBrewer::brewer.pal(name="Set3",n=7)), c("CD21Naive", "Naive", "MBC", "NSw-MBC", "Int-AtBC", "CD11c-MBC", "Ter-AtBC"))
## set all except MBC and AtBC grey
subcell.idents.col_atbc_mbc <- setNames(c(RColorBrewer::brewer.pal(name="Set3",n=11)[c(1,2)],rep("#d9d9d9",9)),  c("CD21Naive", "Naive", "MBC", "NSw-MBC"))
## set all except MBC, AtBC, actMBC, MBC2 grey
subcell.idents.col_atbc_mbc_actmbc_mbc2 <- setNames(c(RColorBrewer::brewer.pal(name="Set3",n=11)[c(1:4)],rep("#d9d9d9",7)),  c("CD21Naive", "Naive", "MBC", "NSw-MBC"))

supp.labs <- c("primary infected", "previously exposed")
names(supp.labs) <- c("primary", "previously")

## UAMP in same color scheme
#pdf(paste0("../",result.dir,"20221021_MJL_UMAP_plot_RhapsodyData_Bcells.pdf"),paper = "a4r")
DimPlot(subcell, cols = subcell.idents.col, label=T) + NoLegend() + ggplot2::labs(x="UMAP1",y="UMAP2")
#dev.off()
```

### overall
```{r}
library(ggfittext)
library(ggalluvial)
library(conflicted)


df <- subcell@meta.data %>% 
  dplyr::select(Time ,CellType_L2, subcell.idents ,Group_rev) %>% rownames_to_column("CellID")  
##======================

# Define color mapping with character names
subcell.idents.col <- c("CD21Naive" = "#8DD3C7", "Naive" = "#FFFFB3", "MBC" = "#BEBADA", 
                         "NSw-MBC" = "#FB8072", "Int-AtBC" = "#80B1D3", "CD11c-MBC" = "#FDB462", 
                         "Ter-AtBC" = "#B3DE69")


plot <- df %>% 
  group_by(Time,subcell.idents) %>% 
  summarise(n = n()) %>%
  mutate(freq = n / sum(n)) %>% 
  ## cluster Naive and 5 has the same numbers of cell, leading to one grey area. 
  ## quick and dirty start
  mutate(n = ifelse(subcell.idents=="Naive" & Time =="Acute",n+0.01,n)) %>% 
  ## quick & dirty end
  ungroup() %>% 
  ggplot(aes(x = Time, 
             stratum = n, 
             alluvium = subcell.idents,
             y = freq,
             fill = subcell.idents, #n
             label = NA)) +#paste0(round(freq*100,1),"%"))) + #label = n
  scale_x_discrete(expand = c(.1, .1)) +
  geom_flow(decreasing = TRUE, alpha=.5) +
  geom_stratum(alpha = .5, decreasing = TRUE) +
  #geom_text(stat = "stratum", size = 2, decreasing = TRUE) +
  ggfittext::geom_fit_text(stat = "stratum", min.size = 1, decreasing=TRUE,show.legend = F) +
  labs(title="B cell clusters over time",
       fill="") +
  theme_mjl_alluvial


#pdf(paste0("../",result.dir,"20221021_MJL_Alluvial_plot_RhapsodyData_Bcells_vs_Time.pdf"),paper = "a4r", height = 6, width = 10)
plot + scale_fill_manual(values=subcell.idents.col) +  ggplot2::aes(label= paste0(round(freq*100,1),"%"))
plot + scale_fill_manual(values=subcell.idents.col_atbc_mbc, limits = c('Int-AtBC', 'Ter-AtBC')) +  ggplot2::aes(label=ifelse(!seurat_clusters %in% c('Int-AtBC', 'Ter-AtBC')," ",paste0(round(freq*100,1),"%")))
plot + scale_fill_manual(values=subcell.idents.col_atbc_mbc_actmbc_mbc2, limits = c( "MBC", "Int-AtBC", "CD11c-MBC", "Ter-AtBC")) + ggplot2::aes(label=ifelse(!seurat_clusters %in% c("MBC", "Int-AtBC", "CD11c-MBC", "Ter-AtBC")," ",paste0(round(freq*100,1),"%")))
#dev.off()

## =======================

names(df)
levels(df$seurat_clusters)




# Load necessary libraries
library(Seurat)
library(dplyr)
library(ggplot2)
library(ggalluvial)
library(scales)       # For percentage formatting
subcell@meta.data$active_ident <- as.character(subcell@active.ident)
# Step 1: Extract metadata
# Ensure 'timepoint' and 'seurat_clusters' match your actual column names
df <- subcell@meta.data %>%
  mutate(CellID = rownames(.)) %>%  # Add row names as a column
  select(CellID, Time = Time, Cluster = active_ident)  # Replace with actual column names

# Step 3: Summarize the data
plot_data <- df %>%
  group_by(Time, Cluster) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Time) %>%
  mutate(Frequency = Count / sum(Count))  # Calculate proportions

# Step 4: Create the alluvial plot
alluvial_plot <- ggplot(plot_data, aes(
  x = Time,
  stratum = Cluster,
  alluvium = Cluster,
  y = Frequency,
  fill = Cluster
)) +
  geom_flow(stat = "alluvium", lode.guidance = "frontback", color = "darkgray") +
  geom_stratum(alpha = 0.8, color = "black") +
  geom_text(
    stat = "stratum",
    aes(label = scales::percent(Frequency, accuracy = 0.1)),  # Only show percentage
    size = 3,
    color = "black",
    vjust = 0.5  # Vertically center the text
  ) +
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
  scale_fill_manual(values = c(
    "CD21Naive" = "#8DD3C7",
    "Naive" = "#FFFFB3",
    "MBC" = "#BEBADA",
    "NSw-MBC" = "#FB8072",
    "Int-AtBC" = "#80B1D3",
    "CD11c-MBC" = "#FDB462",
    "Ter-AtBC" = "#B3DE69"
  )) +
  labs(
    title = "B Cell Cluster Distribution Over Time",
    x = "Time Points",
    y = "Proportion",
    fill = "Cluster"
  ) +
  theme_minimal() +
  theme(
    axis.title.y = element_blank(),
    legend.position = "right",
    panel.grid = element_blank()  # Remove the grid
  )

# Step 5: Save the plot
# Save as PDF
ggsave("alluvial_plot.pdf", plot = alluvial_plot, device = "pdf", width = 10, height = 6)

# Save as PNG
ggsave("alluvial_plot.png", plot = alluvial_plot, device = "png", bg = "white", width = 10, height = 6, dpi = 300)

# Step 5: Display the plot
print(alluvial_plot)
```


## color adjustment for violine plots for alans poster for BSI
```{r}
#pdf(paste0("../",result.dir,"20221103_MJL_RhapsodyData_Bcells_AtBC_MBC2.pdf"),paper = "a4r", height = 6, width = 10)

VlnPlot(subcell, col=subcell.idents.col, features = c("CD1C", "CD24", "CD44", "SELL", "CD74", "CR2"), pt.size = 0, idents = c("Int-AtBC", "Ter-AtBC")) & labs(x="")
#dev.off()

#pdf(paste0("../",result.dir,"20221103_MJL_RhapsodyData_Bcells_AtBC_MBC_MBC2.pdf"),paper = "a4r", height = 6, width = 10)
VlnPlot(subcell, col=subcell.idents.col,features = c("ITGAX", "TBX21"), pt.size = 0, idents = c("Int-AtBC", "Ter-AtBC", "MBC")) & labs(x="")
#dev.off()
```



## Group split
```{r}
plot <- df %>% 
  group_by(Group_rev,Time,subcell.idents) %>% 
  summarise(n = n()) %>%
  mutate(freq = n / sum(n)) %>% 
  ## cluster Naive and 5 has the same numbers of cell, leading to one grey area. 
  ## quick and dirty start
  mutate(n = ifelse(subcell.idents=="Naive" & Time =="Acute",n+0.01,n)) %>% 
  ## quick & dirty end
  ungroup %>% 
  ggplot(aes(x = Time, 
             stratum = n, 
             alluvium = subcell.idents,
             y = freq,
             fill = subcell.idents, #n
             label = NA)) + #paste0(round(freq*100,1),"%"))) + #label = n
  scale_x_discrete(expand = c(.1, .1)) +
  geom_flow(decreasing = TRUE) +
  geom_stratum(alpha = .5, decreasing = TRUE) +
  #geom_text(stat = "stratum", size = 2, decreasing = TRUE) +
  ggfittext::geom_fit_text(stat = "stratum", min.size = 1, decreasing=TRUE,show.legend = F) +
  labs(title="B cell clusters over time",
       fill="") +
  facet_grid(~Group_rev,labeller = labeller(Group_rev = supp.labs)) +
  theme_mjl_alluvial 


#pdf(paste0("../",result.dir,"20221021_MJL_Alluvial_plot_RhapsodyData_Bcells_vs_Time_Group.pdf"),paper = "a4r", height = 6, width = 10)
plot + scale_fill_manual(values=subcell.idents.col) +  ggplot2::aes(label= paste0(round(freq*100,1),"%"))
plot + scale_fill_manual(values=subcell.idents.col, limits = c('Int-AtBC', 'Ter-AtBC')) +  ggplot2::aes(label=ifelse(!subcell.idents %in% c('Int-AtBC', 'Ter-AtBC')," ",paste0(round(freq*100,1),"%")))
plot + scale_fill_manual(values=subcell.idents.col, limits = c('MBC', 'Int-AtBC','CD11c-MBC','Ter-AtBC')) + ggplot2::aes(label=ifelse(!subcell.idents %in% c('MBC', 'Int-AtBC','CD11c-MBC','Ter-AtBC')," ",paste0(round(freq*100,1),"%")))
#dev.off()
```

# === VENN diagrams ===

Alan: "So the idea for the Venn is to have the DEG (if any) among AtBC (and MBC2) across time (one circle for each time point basically)"


### first try 
```{r}
library(ggVennDiagram)
a = "Int-AtBC"
a= "MBC"
a="Ter-AtBC"
a="CD11c-MBC"

Idents(subcell) <- "subcell.idents"
res.Acute <- FindMarkers(subcell,
                         group.by="Time",
                         subset.ident = a,
                         ident.1 = "Acute",# ident.2 = "MBC 2",
                         only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)

res.D10<- FindMarkers(subcell,
                         group.by="Time",
                         subset.ident = a,
                         ident.1 = "D10",# ident.2 = "MBC 2",
                         only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)


res.Y1 <- FindMarkers(subcell,
                         group.by="Time",
                         subset.ident = a,
                         ident.1 = "Y1",# ident.2 = "MBC 2",
                         only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)
## Venn Plotting
#pdf(paste0("../",result.dir,"20221021_MJL_Venn_",a,".pdf"),paper = "a4r", height = 6, width = 6)

plot <- ggVennDiagram::ggVennDiagram(x = list("Acute" = rownames(res.Acute),"D10 " = rownames(res.D10), "Y1" = rownames(res.Y1)),
                                               label = "count",
                                               set_color = TIME_colors[c(1,2,6)],
                                               label_alpha = 0,
                                               edge_size = 0 ) +
  scale_color_manual(values=TIME_colors[c(1,2,6)]) +
  scale_fill_viridis_c() +
  labs(title = a,
       #subtitle = i,
       caption = "Venn Diagramm of DEGs \nFDR <0.05 and log2FC > +-1") +
  xlim(-100, 1000)

plot
#dev.off()

```

## Final version
```{r}
library(ggvenn)
require(ggvenn)

venn_function_SO_Time <- function(data,cellsubset, nice_title){
  Idents(data) <- "subcell.idents"
  res.Acute <- FindMarkers(data,
                           group.by="Time",
                           subset.ident = cellsubset,
                           ident.1 = "Acute",
                           only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)
  
  res.D10<- FindMarkers(data,
                        group.by="Time",
                        subset.ident = cellsubset,
                        ident.1 = "D10",
                        only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)
  
  res.Y1 <- FindMarkers(data,
                        group.by="Time",
                        subset.ident = cellsubset,
                        ident.1 = "Y1",
                        only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)

  
  ## venn plot with overlapp numbers
  venn.plot1 <- ggvenn::ggvenn(list("Acute"=rownames(res.Acute),"D10" = rownames(res.D10),"Y1"= rownames(res.Y1)),
                              show_percentage = FALSE,
                              fill_color = as.character(TIME_colors[c(1,2,6)]), 
                              stroke_size = 0.5,
                              set_name_size = 4) +
    labs(title = nice_title,
         subtitle = cellsubset) +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))
  
return(venn.plot1)
  
  cellsubset <- NULL
  nice_titel <- NULL
  venn.plot1 <- NULL
}

## plotting directly to pdf

#pdf(paste0("../",result.dir,"20221101_MJL_Venn_atBC_MBC_actMBC_MBC2.pdf"),paper = "a4")#, height = 6, width = 6)

gridExtra::grid.arrange(venn_function_SO_Time(data = subcell, cellsubset = "Ter-AtBC", nice_title = "Atypical B cells"),
                        venn_function_SO_Time(data = subcell, cellsubset = "MBC", nice_title = "Memory B cells"),
                        venn_function_SO_Time(data = subcell, cellsubset = "CD11c-MBC", nice_title = "CD11c Memory B cells"),
                        venn_function_SO_Time(data = subcell, cellsubset = "Int-AtBC", nice_title = "Intermediate AtBC"),
                        bottom = textGrob("Venn Diagramm of DEGs \nFDR <0.05 and log2FC > +-1",
                                          gp = gpar(fontface = 3),#, fontsize = 9
                                          hjust = 1, 
                                          x = 1),
                        ncol=2)
#dev.off()
```

```{r}
require(ggvenn)

venn_function_SO_Time_overlappname <- function(data,cellsubset, nice_title){
  Idents(data) <- "subcell.idents"
  res.Acute <- FindMarkers(data,
                           group.by="Time",
                           subset.ident = cellsubset,
                           ident.1 = "Acute",
                           only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)
  
  res.D10<- FindMarkers(data,
                        group.by="Time",
                        subset.ident = cellsubset,
                        ident.1 = "D10",
                        only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)
  
  res.Y1 <- FindMarkers(data,
                        group.by="Time",
                        subset.ident = cellsubset,
                        ident.1 = "Y1",
                        only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)
  
  
  ## venn plot with overlapping gene names
  venn.plot2 <- ggvenn::ggvenn(list("Acute"=rownames(res.Acute),"D10" = rownames(res.D10),"Y1"= rownames(res.Y1)),
                              show_percentage = FALSE,
                              show_elements = T,
                              label_sep = "\n",
                              text_size = 2,
                              fill_color = as.character(TIME_colors[c(1,2,6)]), 
                              stroke_size = 0.5,
                              set_name_size = 4) +
    labs(title = nice_title,
         subtitle = cellsubset) +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))
  
  
  return(venn.plot2)
  
  cellsubset <- NULL
  nice_titel <- NULL
  venn.plot2 <- NULL
}

## plotting directly to pdf

#pdf(paste0("../",result.dir,"20221101_MJL_Venn_atBC_actMBC_detailed.pdf"),paper = "a4")#, height = 6, width = 6)

gridExtra::grid.arrange(venn_function_SO_Time(data = subcell, cellsubset = "Ter-AtBC", nice_title = "Terminal Atypical B cells"),
                        venn_function_SO_Time_overlappname(data = subcell, cellsubset = "Ter-AtBC", nice_title = "Terminal Atypical B cells"),
                        bottom = textGrob("Venn Diagramm of DEGs \nFDR <0.05 and log2FC > +-1",
                                          gp = gpar(fontface = 3),#, fontsize = 9
                                          hjust = 1, 
                                          x = 1),
                        ncol=2)

gridExtra::grid.arrange(venn_function_SO_Time(data = subcell, cellsubset = "Int-AtBC", nice_title = "Intermediate Atypical B cells"),
                        venn_function_SO_Time_overlappname(data = subcell, cellsubset = "Int-AtBC", nice_title = "Intermediate Atypical B cells"),
                        bottom = textGrob("Venn Diagramm of DEGs \nFDR <0.05 and log2FC > +-1",
                                          gp = gpar(fontface = 3),#, fontsize = 9
                                          hjust = 1, 
                                          x = 1),
                        ncol=2)

gridExtra::grid.arrange(venn_function_SO_Time(data = subcell, cellsubset = "CD11c-MBC", nice_title = "CD11c Memory B cells"),
                        venn_function_SO_Time_overlappname(data = subcell, cellsubset = "CD11c-MBC", nice_title = "CD11c Memory B cells"),
                        bottom = textGrob("Venn Diagramm of DEGs \nFDR <0.05 and log2FC > +-1",
                                          gp = gpar(fontface = 3),#, fontsize = 9
                                          hjust = 1, 
                                          x = 1),
                        ncol=2)
#dev.off()

VlnPlot(subcell, features = c("CD24", "CD72", "BIRC3"), split.by = "Time", idents = c("Ter-AtBC", "Int-AtBC"), pt.size = 0, cols = TIME_colors)

# Create VlnPlot
p <- VlnPlot(
  subcell,
  features = "TBX21",
  split.by = "Time",
  idents = c("Ter-AtBC", "Int-AtBC", "CD11c-MBC"),
  pt.size = 0,
  cols = TIME_colors
) + 
  theme(legend.position = "right")  # ensures legend is shown
p

# Save to PDF
ggsave("FigS2TBX21.pdf", plot = p, width = 8, height = 6)
```

```{r}
#"CD21Naive", "Naive", "MBC", "NSw-MBC", "Int-AtBC", "CD11c-MBC", "Ter-AtBC"
top100 <- subcell.markers %>% group_by(cluster) %>% top_n(n = 1000, wt = avg_log2FC)
top100pval <- subset(top100, rowSums(top100[5] < 0.05) > 0)

df <- top100pval[,7:6]
dfsample <- split(df$gene,df$cluster)
length(dfsample)

#The output of length(dfsample) returns how many clusters you have
#Here there at 9 clusters (0, 1, 2, 3, 4, 5, 6, 7 and 8)
#I'm sure there's a better way but you have to make a line like below for each cluster

dfsample$`0` = bitr(dfsample$`0`, fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")
dfsample$`1` = bitr(dfsample$`1`, fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")
dfsample$`2` = bitr(dfsample$`2`, fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")
dfsample$`3` = bitr(dfsample$`3`, fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")
dfsample$`4` = bitr(dfsample$`4`, fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")
dfsample$`5` = bitr(dfsample$`5`, fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")
dfsample$`6` = bitr(dfsample$`6`, fromType="SYMBOL", toType="ENTREZID", OrgDb="org.Hs.eg.db")


#do the same here, a line like below for each cluster
genelist <- list("CD21Naive" = dfsample$`0`$ENTREZID, 
                 "Naive" = dfsample$`1`$ENTREZID,
                 "MBC" = dfsample$`2`$ENTREZID,
                 "NSw-MBC" = dfsample$`3`$ENTREZID,
                 "Int-AtBC" = dfsample$`4`$ENTREZID,
                 "CD11c-MBC" = dfsample$`5`$ENTREZID,
                 "Ter-AtBC" = dfsample$`6`$ENTREZID)

GOclusterplot <- compareCluster(geneCluster = genelist, fun = "enrichGO", OrgDb = "org.Hs.eg.db")
dotplot(GOclusterplot)

GOclusterplot2 <- compareCluster(geneCluster = genelist, fun = "enrichKEGG", organism = "hsa")
dotplot(GOclusterplot2)

GOclusterplot3 <- compareCluster(geneCluster = genelist, fun = "enrichPathway", organism = "human")
dotplot(GOclusterplot3)
```

```{r}
require(ggvenn)

venn_function_SO_Time_overlappname <- function(data,cellsubset, nice_title){
  Idents(data) <- "subcell.idents"
  res.Acute <- FindMarkers(data,
                           group.by="Group",
                           subset.ident = cellsubset,
                           ident.1 = "primary",
                           only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)
  
  res.D10<- FindMarkers(data,
                        group.by="Group",
                        subset.ident = cellsubset,
                        ident.1 = "previously",
                        only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.25) %>% filter(p_val_adj <= 0.05 & abs(avg_log2FC)>1)
  

  
  
  ## venn plot with overlapping gene names
  venn.plot2 <- ggvenn::ggvenn(list("primary"=rownames(res.Acute),"previously" = rownames(res.D10)),
                              show_percentage = FALSE,
                              show_elements = T,
                              label_sep = "\n",
                              text_size = 2,
                              fill_color = as.character(TIME_colors[c(1,2,6)]), 
                              stroke_size = 0.5,
                              set_name_size = 4) +
    labs(title = nice_title,
         subtitle = cellsubset) +
    theme(plot.title = element_text(hjust = 0.5),
          plot.subtitle = element_text(hjust = 0.5))
  
  
  return(venn.plot2)
  
  cellsubset <- NULL
  nice_titel <- NULL
  venn.plot2 <- NULL
}

## plotting directly to pdf

#pdf(paste0("../",result.dir,"20221101_MJL_Venn_atBC_actMBC_detailed.pdf"),paper = "a4")#, height = 6, width = 6)

gridExtra::grid.arrange(venn_function_SO_Time(data = subcell, subcell.idents = "Ter-AtBC", nice_title = "Terminal Atypical B cells"),
                        venn_function_SO_Time_overlappname(data = subcell, subcell.idents = "Ter-AtBC", nice_title = "Terminal Atypical B cells"),
                        bottom = textGrob("Venn Diagramm of DEGs \nFDR <0.05 and log2FC > +-1",
                                          gp = gpar(fontface = 3),#, fontsize = 9
                                          hjust = 1, 
                                          x = 1),
                        ncol=2)

gridExtra::grid.arrange(venn_function_SO_Time(data = subcell, subcell.idents = "Int-AtBC", nice_title = "Intermediate Atypical B cells"),
                        venn_function_SO_Time_overlappname(data = subcell, subcell.idents = "Int-AtBC", nice_title = "Intermediate Atypical B cells"),
                        bottom = textGrob("Venn Diagramm of DEGs \nFDR <0.05 and log2FC > +-1",
                                          gp = gpar(fontface = 3),#, fontsize = 9
                                          hjust = 1, 
                                          x = 1),
                        ncol=2)

gridExtra::grid.arrange(venn_function_SO_Time(data = subcell, subcell.idents = "CD11c-MBC", nice_title = "CD11c Memory B cells"),
                        venn_function_SO_Time_overlappname(data = subcell, subcell.idents = "CD11c-MBC", nice_title = "CD11c Memory B cells"),
                        bottom = textGrob("Venn Diagramm of DEGs \nFDR <0.05 and log2FC > +-1",
                                          gp = gpar(fontface = 3),#, fontsize = 9
                                          hjust = 1, 
                                          x = 1),
                        ncol=2)
#dev.off()

VlnPlot(subcell, features = c("CD24", "CD72", "BIRC3"), split.by = "Time", idents = c("Ter-AtBC", "Int-AtBC"), pt.size = 0, cols = TIME_colors)

# Create VlnPlot
p <- VlnPlot(subcell, 
             features = c("TBX21"), 
             split.by = "Time", 
             idents = c("Ter-AtBC", "Int-AtBC", "CD11c-MBC"), 
             pt.size = 0,
             cols = TIME_colors)

# Add legend manually
p + scale_fill_manual(values = TIME_colors, 
                       name = "Time",
                       breaks = levels(subcell$Time),
                       labels = levels(subcell$Time))
```